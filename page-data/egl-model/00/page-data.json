{"componentChunkName":"component---src-templates-lesson-js","path":"/egl-model/00/","result":{"data":{"allMarkdownRemark":{"nodes":[{"frontmatter":{"length":11,"author":"Kion","slug":"egl-model","source":"https://github.com/kion-dgl/DashGL-EGL-Model-Tutorial","title":"Introduction","index":0},"html":"<p>I guess we should start filling in what we can for the read me files for the\nfirst tutorial, and then we can come back and polish them in the online page.\nTo start off we should probably explain the purpose of this tutorial, which\ncould probably best be described as a way to get familiar with OpenGL by starting\nwith a simple triangle and moving up to the point of being able to display a\nsimple 3d model.</p>\n<p>Next it would probably be a good idea to explain what technology we will be\nusing, which is a Raspberry Pi, which uses either Raspbian or RetroPie (which\nis based on Raspbian anyways). Specifically we want to create a program that we\ncan list under RetroPie, run in a full screen context with hardware acceleration\nand then exit and return to RetroPie.</p>\n<p>We should probably also provide a table for which versions of the Raspberry Pi\nwork, under which versions of Raspbian and RetroPie respectively, and what to do\nwith the Raspberry Pi Zero to get the examples to be able to compile on the\ndevice.</p>\n<p>We should also have either a screenshot or an introduction video which shows the\ncomplete output of what this tutorial will look like once it's complete.</p>\n<p>It would also make sense to describe the languages we chose and why we're using\nit. So first we're generally trying to replicate what it would be like to program\nfor a console or a handheld on the Raspberry Pi. So while it is possible to create\nhomebrew for the Playstation, or Dreamcast we can treat the Raspberry Pi like a\nplatform and program to a similar set of specifications like we would be programming\non one of the other consoles.</p>\n<p>So to replicate working with these consoles we'll be using the C programming language.\nIt's possible to go higher with C++ or Java, but for programming exercises we\ndon't want to use higher languages. We could also go lower with assembler, but we\nwant to finish sometime this decade, so that's not really an option either.</p>\n<p>We're using EGL because it allows us to skip on having to mess around with a\ndesktop environment. We have GTK, FreeGLUT, Raylib, GLFW, and SDL2. SDL2 makes the\nmost sense but running without a desktop requires it to be compiled, so if that\never becomes mainlined, then I'll probably switch tutorials over to that.</p>\n<p>In terms of OpenGL, we'll be using OpenGL 2.0. OpenGL 1.0 is a CPU-bound library\nand I think it helps having a little bit of experience with that as it helps with\nunderstanding OpenGL 2.0 a little bit, but in this tutorial we'll be jumping into\nOpenGL 2.0 directly. And we won't be using OpenGL 3.0 because we won't be using\nthe features, namely vertex array objects (VAO's) which are required in OpenGL 3.0.</p>\n<p>So that should be enough to cover the basics, if you're ready let's get started\nwith a simple triangle.</p>"}]},"allTutorialsJson":{"nodes":[{"lessons":[{"index":0,"title":"Introduction"},{"index":1,"title":"Blue Triangle"},{"index":2,"title":"Red Square"},{"index":3,"title":"Green Circle"},{"index":4,"title":"Fragment Shader"},{"index":5,"title":"Multiple Shapes"},{"index":6,"title":"Fade in and Out"},{"index":7,"title":"Transform Triangle"},{"index":8,"title":"Draw a Cube"},{"index":9,"title":"Textured Cube"},{"index":10,"title":"Render Model"}]}]}},"pageContext":{"slug":"egl-model","index":0}},"staticQueryHashes":[]}