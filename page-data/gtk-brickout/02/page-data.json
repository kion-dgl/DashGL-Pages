{"componentChunkName":"component---src-templates-lesson-js","path":"/gtk-brickout/02/","result":{"data":{"allMarkdownRemark":{"nodes":[{"frontmatter":{"length":18,"author":"Kion","slug":"gtk-brickout","source":"https://github.com/kion-dgl/DashGL-GTK-Brickout-Tutorial/tree/master/02_Draw_a_Triangle","title":"Draw a Triangle","index":2},"html":"<p><img src=\"https://user-images.githubusercontent.com/25621780/128594499-2228a4cd-81ca-4e41-8bf7-c15653df645f.png\" alt=\"bricks_002\"></p>\n<p>Once we have a window open, the next step is going to be a triangle. This step is quite a jump from simply\nopening a window as we will need to initialize OpenGL. We'll start with the main function, where we add a\nGTKGlArea widget to our window.</p>\n<p>File: main.c</p>\n<pre><code class=\"language-c\">int main(int argc, char *argv[]) {\n\n\tGtkWidget *window;\n\tGtkWidget *glArea;\n\n\tgtk_init(&#x26;argc, &#x26;argv);\n\n\t// Initialize Window\n\n\twindow = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n\tgtk_window_set_title(GTK_WINDOW(window), \"Brickout Tutorial\");\n\tgtk_window_set_position(GTK_WINDOW(window), GTK_WIN_POS_CENTER);\n\tgtk_window_set_default_size(GTK_WINDOW(window), 640, 480);\n\tgtk_window_set_type_hint(GTK_WINDOW(window), GDK_WINDOW_TYPE_HINT_UTILITY);\n\tg_signal_connect(window, \"destroy\", G_CALLBACK(gtk_main_quit), NULL);\n\n\t// Initialize GTK GL Area\n\n\tglArea = gtk_gl_area_new();\n\tgtk_widget_set_vexpand(glArea, TRUE);\n\tgtk_widget_set_hexpand(glArea, TRUE);\n\tg_signal_connect(glArea, \"realize\", G_CALLBACK(on_realize), NULL);\n\tg_signal_connect(glArea, \"render\", G_CALLBACK(on_render), NULL);\n\tgtk_container_add(GTK_CONTAINER(window), glArea);\n\n\t// Show widgets\n\n\tgtk_widget_show_all(window);\n\tgtk_main();\n\n\treturn 0;\n\n}\n</code></pre>\n<p>We first create our glArea widget. And then tell the widget to expand to the full width and height of our\n640x480 window with <em>gtk_widget_set_vexpand</em> and <em>gtk_widget_set_hexpand</em>. From there we need to add two\nevents, with callbacks. The first is \"realize\", which will be called when the GtkGLArea is ready to initialize\nso we can set up OpenGL. We also need to add a \"render\" event, that will describe what we want to draw to the\nscreen when our OpenGL context is ready. And then we add our GtkGLArea widget to the window.</p>\n<p>From here let's take a look at the \"realize\" callback.</p>\n<pre><code class=\"language-c\">static void on_realize(GtkGLArea *area) {\n\n\t// Debug Message\n\n\tg_print(\"on realize\\n\");\n\n\tgtk_gl_area_make_current(area);\n\tif(gtk_gl_area_get_error(area) != NULL) {\n\t\tfprintf(stderr, \"Unknown error\\n\");\n\t\treturn;\n\t}\n\n\tconst GLubyte *renderer = glGetString(GL_RENDER);\n\tconst GLubyte *version = glGetString(GL_VERSION);\n\n\tprintf(\"Renderer: %s\\n\", renderer);\n\tprintf(\"OpenGL version supported %s\\n\", version);\n\n\tglClearColor(1.0f, 1.0f, 1.0f, 1.0f);\n\n\tglGenVertexArrays(1, &#x26;vao);\n\tglBindVertexArray(vao);\n\n\tGLfloat triangle_vertices[] = {\n\t\t 0.0,  0.8,\n\t\t-0.8, -0.8,\n\t\t 0.8, -0.8\n\t};\n\t\n\tglGenBuffers(1, &#x26;vbo_triangle);\n\tglBindBuffer(GL_ARRAY_BUFFER, vbo_triangle);\n\tglBufferData(\n\t\tGL_ARRAY_BUFFER,\n\t\tsizeof(triangle_vertices),\n\t\ttriangle_vertices,\n\t\tGL_STATIC_DRAW\n\t);\n\n\tglVertexAttribPointer(0, 2, GL_FLOAT, GL_FALSE, 0, 0);\n\tglEnableVertexAttribArray(0);\n\tglDisableVertexAttribArray(0);\n\t\n\tGLint compile_ok = GL_FALSE;\n\tGLint link_ok = GL_FALSE;\n\n\tconst char *vs_source = \n\t\"#version 120\\n\"\n\t\"attribute vec2 coord2d; \\n\"\n\t\"void main (void) {\\n\"\n\t\"\tgl_Position = vec4(coord2d, 0.0, 1.0);\\n\"\n\t\"}\";\n\n\tconst char *fs_source =\n\t\"#version 120\\n\"\n\t\"void main (void) {\\n\"\n\t\"\tgl_FragColor[0] = 0.0;\\n\"\n\t\"\tgl_FragColor[1] = 0.0;\\n\"\n\t\"\tgl_FragColor[2] = 1.0;\\n\"\n\t\"}\";\n\n\tGLuint fs = glCreateShader(GL_FRAGMENT_SHADER);\n\tglShaderSource(fs, 1, &#x26;fs_source, NULL);\n\tglCompileShader(fs);\n\tglGetShaderiv(fs, GL_COMPILE_STATUS, &#x26;compile_ok);\n\tif(!compile_ok) {\n\t\tfprintf(stderr, \"Error in fragment shader\\n\");\n\t\treturn;\n\t}\n\n\tGLuint vs = glCreateShader(GL_VERTEX_SHADER);\n\tglShaderSource(vs, 1, &#x26;vs_source, NULL);\n\tglCompileShader(vs);\n\tglGetShaderiv(vs, GL_COMPILE_STATUS, &#x26;compile_ok);\n\tif(!compile_ok) {\n\t\tfprintf(stderr, \"Error in vertex shader\\n\");\n\t\treturn;\n\t}\n\n\tprogram = glCreateProgram();\n\tglAttachShader(program, vs);\n\tglAttachShader(program, fs);\n\tglLinkProgram(program);\n\tglGetProgramiv(program, GL_LINK_STATUS, &#x26;link_ok);\n\tif(!link_ok) {\n\t\tfprintf(stderr, \"Error when linking program\\n\");\n\t\treturn;\n\t}\n\n\tconst char *attribute_name = \"coord2d\";\n\tattribute_coord2d = glGetAttribLocation(program, attribute_name);\n\tif(attribute_coord2d == -1) {\n\t\tfprintf(stderr, \"Could not bind attribute %s\\n\", attribute_name);\n\t\treturn;\n\t}\n}\n</code></pre>\n<p>And I'll try and quickly cover what's going here. This should be thought of more\nas a \"Hello World\" aspect of OpenGL to get it started, you don't need to completely\nunderstand everything upfront, as the familiarity will come with more use.</p>\n<p>First we call <em>gtk_gl_area_make_current</em> which will make sure the OpenGL\ncontext uses our GtkGLArea widget. Then for a check we see which versions of\nOpenGL are supported. From there we set the clearColor to white, so that\nwhen we render, something to the screen it will be on a white background.</p>\n<p>From there we set up what are called \"Vertex Array Object\" or vao. These are\nrequired from OpenGL 3.0 and onward, which is what GTKGLArea uses. And these\nare more of an optimization, when drawing more complex scenes. We will set one up,\nand then only use that one, so just think of this as syntax for now.</p>\n<p>From there we set up the coorinates for our triangle. And then we set up our shaders.\nShaders are small programs that run on the GPU and tell the GPU what to do with the\ninformation that we pass into it. We have vertex shaders, which desribe where something\nshould be rendered, and fragment shaders that describe what color something will be.\nWe will cover this information in more detail in later steps.</p>\n<p>File: main.c</p>\n<pre><code class=\"language-c\">static void on_render(GtkGLArea *area, GdkGLContext *context) {\n\n\tg_print(\"on render\\n\");\n\n\tglClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);\n\n\tglUseProgram(program);\n\n\tglBindVertexArray(vao);\n\tglEnableVertexAttribArray(attribute_coord2d);\n\n\tglBindBuffer(GL_ARRAY_BUFFER, vbo_triangle);\n\tglVertexAttribPointer(\n\t\tattribute_coord2d,\n\t\t2,\n\t\tGL_FLOAT,\n\t\tGL_FALSE,\n\t\t0,\n\t\t0\n\t);\n\n\tglDrawArrays(GL_TRIANGLES, 0, 3);\n\tglDisableVertexAttribArray(attribute_coord2d);\n\n}\n</code></pre>\n<p>And last is the render callback. First we clear everything to a white background.\nThen we call tell OpenGL we want to use our shader program. We tell the shader\nprogram how to interpret the 2d coordinates that we pass into it. And then we\ncall <em>glDrawArrays</em> to draw our triangle to the screen.</p>\n<p>We compile with:</p>\n<pre><code>$ gcc `pkg-config --cflags gtk+-3.0` main.c `pkg-config --libs gtk+-3.0` -lepoxy\n</code></pre>\n<p>And then run our program with:</p>\n<pre><code>$ ./a.out\n</code></pre>"}]},"allTutorialsJson":{"nodes":[{"lessons":[{"index":0,"title":"Introduction"},{"index":1,"title":"Open a Window"},{"index":2,"title":"Draw a Triangle"},{"index":3,"title":"Separate Shaders"},{"index":4,"title":"Shader Program"},{"index":5,"title":"Orthagonal Coordinates"},{"index":6,"title":"Draw a Ball"},{"index":7,"title":"Set Ball Position"},{"index":8,"title":"Move a Ball"},{"index":9,"title":"Bounce a Ball"},{"index":10,"title":"Define Ball Struct"},{"index":11,"title":"Draw a Paddle"},{"index":12,"title":"Paddle Uniform Color"},{"index":13,"title":"Keydown Callbacks"},{"index":14,"title":"Paddle Hit Detection"},{"index":15,"title":"Draw Row of Bricks"},{"index":16,"title":"Draw Grid of Bricks"},{"index":17,"title":"Break Some Bricks"}]}]}},"pageContext":{"slug":"gtk-brickout","index":2}},"staticQueryHashes":[]}